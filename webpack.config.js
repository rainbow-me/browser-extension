/* eslint-disable @typescript-eslint/no-var-requires */
const fs = require('fs');
const { join, resolve } = require('path');
require('dotenv').config();

const { VanillaExtractPlugin } = require('@vanilla-extract/webpack-plugin');
const CopyPlugin = require('copy-webpack-plugin');
const Dotenv = require('dotenv-webpack');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const { ProgressPlugin, ProvidePlugin, IgnorePlugin } = require('webpack');
const BundleAnalyzerPlugin =
  require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

const allowList = require('./static/allowlist.json');
const manifest = require('./static/manifest.json');
const manifestFilePath = resolve(__dirname, './build/manifest.json');

const optionalPlugins = [];
if (process.env.ANALYZE_BUNDLE === 'true') {
  optionalPlugins.push(
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      generateStatsFile: true,
      openAnalyzer: true,
    }),
  );
}

const manifestOverride = manifest;
manifestOverride.content_security_policy.extension_pages = `${
  manifestOverride.content_security_policy.extension_pages
} ${allowList.urls.join(' ')};`;

module.exports = {
  devtool: 'cheap-module-eval-source-map',
  entry: {
    background: {
      import: './src/entries/background/index.ts',
      // Use importScripts-based chunk loading for MV3 service worker.
      chunkLoading: 'import-scripts',
    },
    contentscript: './src/entries/content/index.ts',
    inpage: './src/entries/inpage/index.ts',
    popup: './src/entries/popup/index.ts',
  },
  module: {
    rules: [
      {
        // Many node_modules ship ESM files with extensionless imports
        // (e.g. `export * from './assert'` instead of `'./assert.js'`).
        // This is invalid under webpack 5 strict ESM but very common.
        test: /\.m?js$/,
        resolve: { fullySpecified: false },
      },
      {
        test: /\.tsx?$/,
        use: [
          {
            loader: 'ts-loader',
            options: {
              transpileOnly: true,
            },
          },
        ],
        exclude: /node_modules/,
      },
      {
        test: /\.(woff2|png|svg|mp3)?$/,
        use: 'file-loader',
      },
      {
        test: /\.worker.js$/,
        loader: 'worker-loader',
      },
      {
        test: /\.vanilla\.css$/i, // Targets only CSS files generated by vanilla-extract
        use: [
          MiniCssExtractPlugin.loader,
          {
            loader: require.resolve('css-loader'),
            options: {
              url: false, // Required as image imports should be handled via JS/TS import statements
            },
          },
        ],
      },
    ],
  },
  plugins: [
    ...optionalPlugins,
    new IgnorePlugin({
      checkResource(resource) {
        return /.*\/wordlists\/(?!english).*\.json/.test(resource);
      },
    }),
    new Dotenv({ allowEmptyValues: true }),
    new HtmlWebpackPlugin({
      chunks: ['popup'],
      template: './src/entries/popup/index.html',
      filename: 'popup.html',
    }),
    new CopyPlugin({
      patterns: [
        {
          from: 'static',
          to: './',
          transform(content, absoluteFrom) {
            // Minify JSON files during copy
            if (absoluteFrom.endsWith('.json')) {
              return Buffer.from(
                JSON.stringify(JSON.parse(content.toString())),
              );
            }
            return content;
          },
        },
      ],
    }),
    new MiniCssExtractPlugin(),
    new ProgressPlugin(),
    new VanillaExtractPlugin(),
    // Work around for Buffer is undefined:
    // https://github.com/webpack/changelog-v5/issues/10
    new ProvidePlugin({
      Buffer: ['buffer', 'Buffer'],
    }),
    // Custom plugin to apply the sandbox
    {
      apply: (compiler) => {
        compiler.hooks.afterEmit.tap('AfterEmitPlugin', () => {
          if (
            fs.writeFileSync(
              manifestFilePath,
              JSON.stringify(manifestOverride, null, 2),
            )
          ) {
            process.stdout.write('manifest overwritten successfuly');
          } else {
            process.stderr.write('manifest override failed');
          }
        });
      },
    },
  ],
  resolve: {
    alias: {
      '~': resolve(__dirname, 'src/'),
      static: resolve(__dirname, 'static/'),
    },
    fallback: {
      fs: false,
      tls: false,
      net: false,
      path: false,
      zlib: false,
      http: false,
      stream: 'stream-browserify',
      https: 'agent-base',
      crypto: false,
    },
    extensions: ['.tsx', '.ts', '.js', '.json'],
    mainFields: ['module', 'browser', 'main'],
    conditionNames: ['import', 'module', 'browser', 'default'],
  },
  output: {
    filename: '[name].js',
    path: join(__dirname, 'build'),
    publicPath: '/',
  },
};
